<?php

/**
 * @file
 * Contains search_api_postgresql.module.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\search_api\ServerInterface;
use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_help().
 */
function search_api_postgresql_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.search_api_postgresql':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Search API PostgreSQL module provides a PostgreSQL backend for the Search API module with native full-text search and AI-powered vector search capabilities.') . '</p>';
      $output .= '<h3>' . t('Features') . '</h3>';
      $output .= '<ul>';
      $output .= '<li>' . t('Native PostgreSQL full-text search using tsvector') . '</li>';
      $output .= '<li>' . t('AI-powered semantic search using OpenAI embeddings') . '</li>';
      $output .= '<li>' . t('Hybrid search combining traditional and vector search') . '</li>';
      $output .= '<li>' . t('Secure credential storage using Key module') . '</li>';
      $output .= '<li>' . t('Queue-based embedding generation') . '</li>';
      $output .= '<li>' . t('Comprehensive analytics and monitoring') . '</li>';
      $output .= '</ul>';
      $output .= '<h3>' . t('Configuration') . '</h3>';
      $output .= '<p>' . t('Configure PostgreSQL search servers at <a href=":url">Search API servers</a>.', [
        ':url' => '/admin/config/search/search-api',
      ]) . '</p>';
      $output .= '<p>' . t('For AI features, ensure you have:') . '</p>';
      $output .= '<ul>';
      $output .= '<li>' . t('PostgreSQL pgvector extension installed') . '</li>';
      $output .= '<li>' . t('API keys configured using the Key module') . '</li>';
      $output .= '<li>' . t('Appropriate AI service (Azure OpenAI or OpenAI) credentials') . '</li>';
      $output .= '</ul>';
      $output .= '<h3>' . t('Administration') . '</h3>';
      $output .= '<p>' . t('Access the main administration dashboard at <a href=":dashboard_url">Search API PostgreSQL Administration</a>.', [
        ':dashboard_url' => '/admin/config/search/search-api-postgresql',
      ]) . '</p>';
      return $output;

    case 'entity.search_api_server.canonical':
      $server = $route_match->getParameter('search_api_server');
      if ($server && $server->getBackend() && in_array($server->getBackend()->getPluginId(), ['postgresql', 'postgresql_vector', 'azure_postgresql_vector'])) {
        $output = '<p>' . t('This server uses the PostgreSQL backend with the following features:') . '</p>';
        $output .= '<ul>';
        $output .= '<li>' . t('Native PostgreSQL full-text search') . '</li>';
        
        $config = $server->getBackend()->getConfiguration();
        if (!empty($config['ai_embeddings']['enabled'])) {
          $output .= '<li>' . t('AI-powered vector search enabled') . '</li>';
          if (!empty($config['hybrid_search']['enabled'])) {
            $output .= '<li>' . t('Hybrid search combining text and vector search') . '</li>';
          }
        }
        $output .= '</ul>';
        
        // Add link to server-specific administration
        $server_admin_url = '/admin/config/search/search-api-postgresql/server/' . $server->id() . '/status';
        $output .= '<p>' . t('<a href=":url">View detailed server status and analytics</a>', [
          ':url' => $server_admin_url,
        ]) . '</p>';
        
        return $output;
      }
      break;
  }
}

/**
 * Implements hook_cron().
 */
function search_api_postgresql_cron() {
  $settings = \Drupal::config('search_api_postgresql.settings');
  
  // Only run maintenance tasks if analytics are enabled
  if (!$settings->get('analytics.enabled')) {
    return;
  }

  $logger = \Drupal::logger('search_api_postgresql');

  try {
    // Process embedding queue with configurable limits
    if (\Drupal::hasService('search_api_postgresql.embedding_queue_manager')) {
      $queue_manager = \Drupal::service('search_api_postgresql.embedding_queue_manager');
      if ($queue_manager) {
        $max_items = $settings->get('performance.cron_max_items') ?: 50;
        $max_time = $settings->get('performance.cron_max_time') ?: 30;
        
        $processed = $queue_manager->processQueue([
          'max_items' => $max_items, 
          'max_time' => $max_time
        ]);
        
        if ($processed > 0) {
          $logger->info('Processed @count embedding queue items.', ['@count' => $processed]);
        }
      }
    }

    // Clean up old cache entries
    if (\Drupal::hasService('search_api_postgresql.cache_manager')) {
      $cache_manager = \Drupal::service('search_api_postgresql.cache_manager');
      if ($cache_manager) {
        $cleaned = $cache_manager->performMaintenance();
        if ($cleaned > 0) {
          $logger->info('Cleaned up @count old cache entries.', ['@count' => $cleaned]);
        }
      }
    }

    // Update analytics aggregates
    if (\Drupal::hasService('search_api_postgresql.analytics')) {
      $analytics = \Drupal::service('search_api_postgresql.analytics');
      if ($analytics) {
        $aggregated = $analytics->aggregateDailyStats();
        if ($aggregated > 0) {
          $logger->info('Aggregated @count daily analytics records.', ['@count' => $aggregated]);
        }
      }
    }

    // Log maintenance completion (only if any work was done)
    $logger->debug('Completed cron maintenance tasks.');
  }
  catch (\Exception $e) {
    $logger->error('Error in cron: @message', [
      '@message' => $e->getMessage(),
    ]);
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Cleans up data when search entities are deleted.
 */
function search_api_postgresql_entity_delete($entity) {
  // Clean up when search API servers are deleted
  if ($entity->getEntityTypeId() === 'search_api_server') {
    search_api_postgresql_search_api_server_delete($entity);
  }
  
  // Clean up when search API indexes are deleted
  if ($entity->getEntityTypeId() === 'search_api_index') {
    search_api_postgresql_search_api_index_delete($entity);
  }
}

/**
 * Implements hook_search_api_server_delete().
 *
 * Cleans up server-specific data when a search server is deleted.
 */
function search_api_postgresql_search_api_server_delete($server) {
  // Only clean up if the server is using PostgreSQL backend
  try {
    $backend = $server->getBackend();
    if (!$backend || $backend->getPluginId() !== 'postgresql') {
      return;
    }
  } catch (\Exception $e) {
    // Backend not available, skip cleanup
    return;
  }

  $logger = \Drupal::logger('search_api_postgresql');

  try {
    $database = \Drupal::database();
    $schema = $database->schema();
    
    $cleaned_count = 0;
    
    // Clean up server-specific metrics
    if ($schema->tableExists('search_api_postgresql_metrics')) {
      $count = $database->delete('search_api_postgresql_metrics')
        ->condition('server_id', $server->id())
        ->execute();
      $cleaned_count += $count;
    }
    
    // Clean up server-specific cache entries
    if (\Drupal::hasService('search_api_postgresql.cache_manager')) {
      $cache_manager = \Drupal::service('search_api_postgresql.cache_manager');
      if ($cache_manager) {
        $cache_manager->clear();
      }
    }
    
    if ($cleaned_count > 0) {
      $logger->info('Cleaned up @count metrics records for deleted server: @server', [
        '@count' => $cleaned_count,
        '@server' => $server->id(),
      ]);
    }
    
    // Clear related caches
    $cache_tags = [
      'search_api_postgresql:server:' . $server->id(),
      'search_api_postgresql:analytics',
      'search_api_postgresql:dashboard',
    ];
    
    \Drupal::service('cache_tags.invalidator')->invalidateTags($cache_tags);
    
  }
  catch (\Exception $e) {
    $logger->error('Error cleaning up server data: @message', [
      '@message' => $e->getMessage(),
    ]);
  }
}

/**
 * Implements hook_search_api_index_delete().
 *
 * Cleans up index-specific data when a search index is deleted.
 */
function search_api_postgresql_search_api_index_delete($index) {
  // Only clean up if the index is using a PostgreSQL backend
  $server = $index->getServerInstance();
  if (!$server || $server->isNew()) {
    return;
  }
  
  try {
    $backend = $server->getBackend();
    if (!$backend || $backend->getPluginId() !== 'postgresql') {
      return;
    }
  } catch (\Exception $e) {
    // Backend not available, skip cleanup
    return;
  }

  $logger = \Drupal::logger('search_api_postgresql');

  try {
    $database = \Drupal::database();
    $schema = $database->schema();
    
    $cleaned_count = 0;
    
    // Clean up index-specific metrics
    if ($schema->tableExists('search_api_postgresql_metrics')) {
      $count = $database->delete('search_api_postgresql_metrics')
        ->condition('index_id', $index->id())
        ->execute();
      $cleaned_count += $count;
    }
    
    // Clean up index-specific cache entries
    if (\Drupal::hasService('search_api_postgresql.cache_manager')) {
      $cache_manager = \Drupal::service('search_api_postgresql.cache_manager');
      if ($cache_manager) {
        $cache_manager->clear();
      }
    }
    
    if ($cleaned_count > 0) {
      $logger->info('Cleaned up @count metrics records for deleted index: @index', [
        '@count' => $cleaned_count,
        '@index' => $index->id(),
      ]);
    }
    
    // Clear related caches
    $cache_tags = [
      'search_api_postgresql:index:' . $index->id(),
      'search_api_postgresql:analytics',
      'search_api_postgresql:dashboard',
    ];
    
    \Drupal::service('cache_tags.invalidator')->invalidateTags($cache_tags);
    
  }
  catch (\Exception $e) {
    $logger->error('Error cleaning up index data: @message', [
      '@message' => $e->getMessage(),
    ]);
  }
}

/**
 * Implements hook_theme().
 */
function search_api_postgresql_theme() {
  return [
    'search_api_postgresql_stat_card' => [
      'variables' => [
        'title' => '',
        'value' => '',
        'subtitle' => '',
        'icon' => '',
        'color' => 'blue',
      ],
      'template' => 'search-api-postgresql-stat-card',
    ],
    'search_api_postgresql_metric_chart' => [
      'variables' => [
        'title' => '',
        'data' => [],
        'type' => 'line',
        'unit' => '',
      ],
      'template' => 'search-api-postgresql-metric-chart',
    ],
    'search_api_postgresql_cost_card' => [
      'variables' => [
        'title' => '',
        'cost' => 0,
        'api_calls' => 0,
        'tokens' => 0,
        'trend' => 0,
        'is_projection' => FALSE,
      ],
      'template' => 'search-api-postgresql-cost-card',
    ],
    'search_api_postgresql_dashboard' => [
      'variables' => [
        'server' => NULL,
        'stats' => [],
        'charts' => [],
        'alerts' => [],
        'overview_stats' => [],
        'servers' => [],
        'indexes' => [],
        'health_checks' => [],
        'quick_actions' => [],
        'auto_refresh' => TRUE,
      ],
      'template' => 'search-api-postgresql-dashboard',
    ],
  ];
}

/**
 * Implements hook_page_attachments().
 *
 * Attaches admin CSS/JS to relevant pages.
 */
function search_api_postgresql_page_attachments(array &$attachments) {
  $route_match = \Drupal::routeMatch();
  $route_name = $route_match->getRouteName();
  
  // Admin routes that should load the admin library
  $admin_routes = [
    // Main admin routes
    'search_api_postgresql.admin.dashboard',
    'search_api_postgresql.admin.analytics',
    'search_api_postgresql.admin.embedding_management',
    'search_api_postgresql.admin.cache_management',
    'search_api_postgresql.admin.queue_management',
    'search_api_postgresql.admin.configuration_test',
    'search_api_postgresql.admin.bulk_regenerate',
    
    // Server and index specific routes
    'search_api_postgresql.admin.server_status',
    'search_api_postgresql.admin.index_embeddings',
    
    // Search API routes when using PostgreSQL backend
    'entity.search_api_server.canonical',
    'entity.search_api_server.edit_form',
    'entity.search_api_server.add_form',
    'entity.search_api_index.canonical',
    'entity.search_api_index.edit_form',
  ];
  
  if (in_array($route_name, $admin_routes)) {
    // Check if this is a PostgreSQL-related page
    $should_attach = TRUE;
    
    // For Search API entity routes, only attach if using PostgreSQL backend
    if (strpos($route_name, 'entity.search_api_') === 0) {
      $should_attach = FALSE;
      
      if ($route_name === 'entity.search_api_server.canonical' || 
          $route_name === 'entity.search_api_server.edit_form') {
        $server = $route_match->getParameter('search_api_server');
        if ($server && !$server->isNew()) {
          try {
            $backend = $server->getBackend();
            $should_attach = ($backend && $backend->getPluginId() === 'postgresql');
          } catch (\Exception $e) {
            $should_attach = FALSE;
          }
        }
      }
      elseif ($route_name === 'entity.search_api_index.canonical' || 
              $route_name === 'entity.search_api_index.edit_form') {
        $index = $route_match->getParameter('search_api_index');
        if ($index && $index->getServerInstance() && !$index->getServerInstance()->isNew()) {
          try {
            $server = $index->getServerInstance();
            $backend = $server->getBackend();
            $should_attach = ($backend && $backend->getPluginId() === 'postgresql');
          } catch (\Exception $e) {
            $should_attach = FALSE;
          }
        }
      }
      elseif ($route_name === 'entity.search_api_server.add_form') {
        // Always attach on add form in case user selects PostgreSQL backend
        $should_attach = TRUE;
      }
    }
    
    if ($should_attach) {
      $attachments['#attached']['library'][] = 'search_api_postgresql/admin';
      
      // Add Drupal settings for JavaScript
      $settings = \Drupal::config('search_api_postgresql.settings');
      $attachments['#attached']['drupalSettings']['searchApiPostgreSQL'] = [
        'refreshInterval' => $settings->get('performance.refresh_interval') ?: 30000,
        'autoRefresh' => $settings->get('display.auto_refresh') ?? TRUE,
        'basePath' => \Drupal::request()->getBasePath(),
      ];
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for search_api_server_form.
 *
 * Adds validation and additional configuration options to server forms.
 */
function search_api_postgresql_form_search_api_server_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $server = $form_state->getFormObject()->getEntity();
  
  // Skip backend checks for new servers that don't have a backend configured yet
  if (!$server || $server->isNew()) {
    return;
  }
  
  // Only modify if this is a PostgreSQL backend
  try {
    $backend = $server->getBackend();
    if ($backend && $backend->getPluginId() === 'postgresql') {
      // Add custom validation
      $form['#validate'][] = 'search_api_postgresql_server_form_validate';
      
      // Add helpful information
      if (!empty($form['backend_config'])) {
        $form['backend_config']['#prefix'] = '<div class="messages messages--info">' . 
          t('This server uses the PostgreSQL backend. Ensure your database has the required extensions installed for optimal performance.') . 
          '</div>';
      }
      
      // Add link to test configuration
      $test_url = '/admin/config/search/search-api-postgresql/test-config';
      $form['backend_config']['#suffix'] = '<p>' . 
        t('<a href="@url" class="button">Test PostgreSQL Configuration</a>', ['@url' => $test_url]) . 
        '</p>';
    }
  } catch (\Exception $e) {
    // Server doesn't have a valid backend configured, skip modifications
    return;
  }
}

/**
 * Validation callback for PostgreSQL server forms.
 */
function search_api_postgresql_server_form_validate($form, FormStateInterface $form_state) {
  // Skip validation for AJAX requests (like Test Connection button)
  if ($form_state->getTriggeringElement() && isset($form_state->getTriggeringElement()['#ajax'])) {
    return;
  }
  
  $values = $form_state->getValues();
  
  // Validate connection configuration
  if (!empty($values['backend_config']['connection'])) {
    $connection = $values['backend_config']['connection'];
    
    // Ensure either password or password_key is provided
    if (empty($connection['password']) && empty($connection['password_key'])) {
      $form_state->setErrorByName(['backend_config']['connection']['password'], 
        \Drupal::translation()->translate('Either a password or a password key reference must be provided.'));
    }
    
    // Validate SSL configuration
    if (!empty($connection['ssl_mode']) && $connection['ssl_mode'] !== 'disable') {
      $settings = \Drupal::config('search_api_postgresql.settings');
      if ($settings->get('security.require_https') && empty($connection['ssl_ca'])) {
        $form_state->setErrorByName(['backend_config']['connection']['ssl_ca'], 
          \Drupal::translation()->translate('SSL certificate path is required when using secure SSL modes.'));
      }
    }
    
    // Validate database connection parameters
    if (empty($connection['host'])) {
      $form_state->setErrorByName(['backend_config']['connection']['host'], 
        \Drupal::translation()->translate('Database host is required.'));
    }

    if (empty($connection['port'])) {
      $form_state->setErrorByName(['backend_config']['connection']['port'], 
        \Drupal::translation()->translate('Database port is required.'));
    }

    if (empty($connection['database'])) {
      $form_state->setErrorByName(['backend_config']['connection']['database'], 
        \Drupal::translation()->translate('Database name is required.'));
    }

    if (empty($connection['username'])) {
      $form_state->setErrorByName(['backend_config']['connection']['username'], 
        \Drupal::translation()->translate('Database username is required.'));
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for search_api_index_form.
 *
 * Adds PostgreSQL-specific options to index forms.
 */
function search_api_postgresql_form_search_api_index_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $index = $form_state->getFormObject()->getEntity();
  
  // Only modify if index is using a PostgreSQL backend
  $server = $index->getServerInstance();
  if ($server && !$server->isNew()) {
    try {
      $backend = $server->getBackend();
      if ($backend && $backend->getPluginId() === 'postgresql') {
        // Add link to embedding management for existing indexes
        if (!$index->isNew()) {
          $embedding_url = '/admin/config/search/search-api-postgresql/index/' . $index->id() . '/embeddings';
          $form['actions']['embedding_management'] = [
            '#type' => 'link',
            '#title' => t('Manage Embeddings'),
            '#url' => \Drupal\Core\Url::fromUserInput($embedding_url),
            '#attributes' => [
              'class' => ['button', 'button--secondary'],
            ],
            '#weight' => 10,
          ];
        }
      }
    } catch (\Exception $e) {
      // Server doesn't have a valid backend configured, skip modifications
      return;
    }
  }
}

/**
 * Implements hook_library_info_alter().
 *
 * Modifies library definitions as needed.
 */
function search_api_postgresql_library_info_alter(&$libraries, $extension) {
  // Add version information to admin library
  if ($extension === 'search_api_postgresql' && isset($libraries['admin'])) {
    $module_info = \Drupal::service('extension.list.module')->getExtensionInfo('search_api_postgresql');
    $libraries['admin']['version'] = $module_info['version'] ?? '1.x-dev';
    
    // Add dependencies based on module configuration
    $settings = \Drupal::config('search_api_postgresql.settings');
    if ($settings->get('performance.lazy_load_charts')) {
      $libraries['admin']['dependencies'][] = 'core/drupal.ajax';
    }
  }
}

/**
 * Implements hook_mail().
 *
 * Defines mail templates for notifications.
 */
function search_api_postgresql_mail($key, &$message, $params) {
  switch ($key) {
    case 'cost_threshold_exceeded':
      $message['subject'] = t('Search API PostgreSQL: Cost threshold exceeded');
      $message['body'][] = t('The daily cost threshold of $@threshold has been exceeded.', [
        '@threshold' => $params['threshold'],
      ]);
      $message['body'][] = t('Current daily cost: $@cost', [
        '@cost' => $params['current_cost'],
      ]);
      $message['body'][] = t('Please review your AI usage and consider adjusting your configuration.');
      break;
      
    case 'error_threshold_exceeded':
      $message['subject'] = t('Search API PostgreSQL: Error threshold exceeded');
      $message['body'][] = t('The error threshold of @threshold errors has been exceeded.', [
        '@threshold' => $params['threshold'],
      ]);
      $message['body'][] = t('Current error count: @count', [
        '@count' => $params['error_count'],
      ]);
      $message['body'][] = t('Please check your configuration and system logs.');
      break;
  }
}

/**
 * Implements hook_cron_queue_info().
 *
 * Defines cron queues for the module.
 */
function search_api_postgresql_cron_queue_info() {
  $queues = [];
  
  $queues['search_api_postgresql_embedding'] = [
    'worker callback' => 'search_api_postgresql_process_embedding_queue_item',
    'time' => 60,
  ];
  
  return $queues;
}

/**
 * Queue worker callback for embedding generation.
 */
function search_api_postgresql_process_embedding_queue_item($data) {
  if (\Drupal::hasService('search_api_postgresql.embedding_queue_manager')) {
    $queue_manager = \Drupal::service('search_api_postgresql.embedding_queue_manager');
    if ($queue_manager) {
      return $queue_manager->processItem($data);
    }
  }
  
  throw new \Exception('Embedding queue manager service not available.');
}