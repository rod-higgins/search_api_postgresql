<?php

/**
 * @file
 * Search API PostgreSQL module hooks and functionality.
 */

use Drupal\Core\Url;
use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_help().
 */
function search_api_postgresql_help($route_name, $route_match) {
  if ($route_name == 'help.page.search_api_postgresql') {
    $output = '<h3>' . t('About') . '</h3>';
    $output .= '<p>' . t('The Search API PostgreSQL module provides a PostgreSQL backend for the Search API module with support for full-text search, vector embeddings, and AI-powered search capabilities.') . '</p>';

    $output .= '<h3>' . t('Features') . '</h3>';
    $output .= '<ul>';
    $output .= '<li>' . t('Native PostgreSQL full-text search') . '</li>';
    $output .= '<li>' . t('Vector search using pgvector extension') . '</li>';
    $output .= '<li>' . t('AI-powered embeddings integration') . '</li>';
    $output .= '<li>' . t('Hybrid search combining traditional and semantic search') . '</li>';
    $output .= '</ul>';

    $output .= '<h3>' . t('Requirements') . '</h3>';
    $output .= '<ul>';
    $output .= '<li>' . t('PostgreSQL 12 or higher') . '</li>';
    $output .= '<li>' . t('pgvector extension (for vector search features)') . '</li>';
    $output .= '<li>' . t('Key module (for secure API key storage)') . '</li>';
    $output .= '</ul>';

    return $output;
  }
}

/**
 * Implements hook_cron().
 */
function search_api_postgresql_cron() {
  $settings = \Drupal::config('search_api_postgresql.settings');
  
  // Only run maintenance tasks if analytics are enabled
  if (!$settings->get('analytics.enabled')) {
    return;
  }

  $logger = \Drupal::logger('search_api_postgresql');

  try {
    // Process embedding queue with configurable limits
    if (\Drupal::hasService('search_api_postgresql.embedding_queue_manager')) {
      $queue_manager = \Drupal::service('search_api_postgresql.embedding_queue_manager');
      if ($queue_manager) {
        $max_items = $settings->get('performance.cron_max_items') ?: 50;
        $max_time = $settings->get('performance.cron_max_time') ?: 30;
        
        $processed = $queue_manager->processQueue([
          'max_items' => $max_items, 
          'max_time' => $max_time
        ]);
        
        if ($processed > 0) {
          $logger->info('Processed @count embedding queue items.', ['@count' => $processed]);
        }
      }
    }

    // Clean up old cache entries
    if (\Drupal::hasService('search_api_postgresql.cache_manager')) {
      $cache_manager = \Drupal::service('search_api_postgresql.cache_manager');
      if ($cache_manager) {
        $maintenance_result = $cache_manager->performMaintenance();
        $cleaned = $maintenance_result['entries_cleaned'] ?? 0;
        if ($cleaned > 0) {
          $logger->info('Cleaned up @count old cache entries.', ['@count' => $cleaned]);
        }
      }
    }

    // Update analytics aggregates
    if (\Drupal::hasService('search_api_postgresql.analytics')) {
      $analytics = \Drupal::service('search_api_postgresql.analytics');
      if ($analytics) {
        $aggregated = $analytics->aggregateDailyStats();
        if ($aggregated > 0) {
          $logger->info('Aggregated @count daily analytics records.', ['@count' => $aggregated]);
        }
      }
    }

    // Log maintenance completion (only if any work was done)
    $logger->debug('Completed cron maintenance tasks.');
  }
  catch (\Exception $e) {
    $logger->error('Error in cron: @message', [
      '@message' => $e->getMessage(),
    ]);
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Cleans up data when search entities are deleted.
 */
function search_api_postgresql_entity_delete($entity) {
  // Clean up when search API servers are deleted
  if ($entity->getEntityTypeId() === 'search_api_server') {
    search_api_postgresql_search_api_server_delete($entity);
  }
  
  // Clean up when search API indexes are deleted
  if ($entity->getEntityTypeId() === 'search_api_index') {
    search_api_postgresql_search_api_index_delete($entity);
  }
}

/**
 * Implements hook_search_api_server_delete().
 *
 * Cleans up server-specific data when a search server is deleted.
 */
function search_api_postgresql_search_api_server_delete($server) {
  // Only clean up if the server is using PostgreSQL backend
  try {
    $backend = $server->getBackend();
    if (!$backend || $backend->getPluginId() !== 'postgresql') {
      return;
    }
  } catch (\Exception $e) {
    // Backend not available, skip cleanup
    return;
  }

  $logger = \Drupal::logger('search_api_postgresql');

  try {
    $database = \Drupal::database();
    $schema = $database->schema();
    
    $cleaned_count = 0;
    
    // Clean up server-specific metrics
    if ($schema->tableExists('search_api_postgresql_metrics')) {
      $count = $database->delete('search_api_postgresql_metrics')
        ->condition('server_id', $server->id())
        ->execute();
      $cleaned_count += $count;
    }
    
    // Clean up server-specific cache entries
    if (\Drupal::hasService('search_api_postgresql.cache_manager')) {
      $cache_manager = \Drupal::service('search_api_postgresql.cache_manager');
      if ($cache_manager) {
        $cache_manager->clear(); // FIXED: Now uses the wrapper method
      }
    }
    
    if ($cleaned_count > 0) {
      $logger->info('Cleaned up @count metrics records for deleted server: @server', [
        '@count' => $cleaned_count,
        '@server' => $server->id(),
      ]);
    }
    
    // Clear related caches
    $cache_tags = [
      'search_api_postgresql:server:' . $server->id(),
      'search_api_postgresql:analytics',
      'search_api_postgresql:dashboard',
    ];
    
    \Drupal::service('cache_tags.invalidator')->invalidateTags($cache_tags);
    
  }
  catch (\Exception $e) {
    $logger->error('Error cleaning up server data: @message', [
      '@message' => $e->getMessage(),
    ]);
  }
}

/**
 * Implements hook_search_api_index_delete().
 *
 * Cleans up index-specific data when a search index is deleted.
 */
function search_api_postgresql_search_api_index_delete($index) {
  // Only clean up if the index is using a PostgreSQL backend
  $server = $index->getServerInstance();
  if (!$server || $server->isNew()) {
    return;
  }
  
  try {
    $backend = $server->getBackend();
    if (!$backend || $backend->getPluginId() !== 'postgresql') {
      return;
    }
  } catch (\Exception $e) {
    // Backend not available, skip cleanup
    return;
  }

  $logger = \Drupal::logger('search_api_postgresql');

  try {
    $database = \Drupal::database();
    $schema = $database->schema();
    
    $cleaned_count = 0;
    
    // Clean up index-specific metrics
    if ($schema->tableExists('search_api_postgresql_metrics')) {
      $count = $database->delete('search_api_postgresql_metrics')
        ->condition('index_id', $index->id())
        ->execute();
      $cleaned_count += $count;
    }
    
    // Clean up index-specific cache entries
    if (\Drupal::hasService('search_api_postgresql.cache_manager')) {
      $cache_manager = \Drupal::service('search_api_postgresql.cache_manager');
      if ($cache_manager) {
        $cache_manager->clearByIndex($index->id()); // FIXED: Now uses the specific wrapper method
      }
    }
    
    if ($cleaned_count > 0) {
      $logger->info('Cleaned up @count metrics records for deleted index: @index', [
        '@count' => $cleaned_count,
        '@index' => $index->id(),
      ]);
    }
    
    // Clear related caches
    $cache_tags = [
      'search_api_postgresql:index:' . $index->id(),
      'search_api_postgresql:analytics',
      'search_api_postgresql:dashboard',
    ];
    
    \Drupal::service('cache_tags.invalidator')->invalidateTags($cache_tags);
    
  }
  catch (\Exception $e) {
    $logger->error('Error cleaning up index data: @message', [
      '@message' => $e->getMessage(),
    ]);
  }
}

/**
 * Implements hook_theme().
 */
function search_api_postgresql_theme() {
  return [
    'search_api_postgresql_dashboard' => [
      'variables' => [
        'dashboard_data' => [],
        'server_stats' => [],
        'health_checks' => [],
      ],
      'template' => 'search-api-postgresql-dashboard',
    ],
    'search_api_postgresql_server_status' => [
      'variables' => [
        'server' => NULL,
        'status_data' => [],
        'analytics_data' => [],
      ],
      'template' => 'search-api-postgresql-server-status',
    ],
    'search_api_postgresql_index_analytics' => [
      'variables' => [
        'index' => NULL,
        'analytics_data' => [],
        'embedding_stats' => [],
      ],
      'template' => 'search-api-postgresql-index-analytics',
    ],
    // ADD THIS MISSING THEME HOOK:
    'search_api_postgresql_stat_card' => [
      'variables' => [
        'title' => NULL,
        'value' => NULL,
        'subtitle' => NULL,
        'icon' => NULL,
        'color' => 'blue',
      ],
      'template' => 'search-api-postgresql-stat-card',
    ],
  ];
}

/**
 * Implements hook_library_info_alter().
 *
 * Modifies library definitions as needed.
 */
function search_api_postgresql_library_info_alter(&$libraries, $extension) {
  // Add version information to admin library
  if ($extension === 'search_api_postgresql' && isset($libraries['admin'])) {
    $module_info = \Drupal::service('extension.list.module')->getExtensionInfo('search_api_postgresql');
    $libraries['admin']['version'] = $module_info['version'] ?? '1.x-dev';
    
    // Add dependencies based on module configuration
    $settings = \Drupal::config('search_api_postgresql.settings');
    if ($settings->get('performance.lazy_load_charts')) {
      $libraries['admin']['dependencies'][] = 'core/drupal.ajax';
    }
  }
}

/**
 * Implements hook_mail().
 *
 * Defines mail templates for notifications.
 */
function search_api_postgresql_mail($key, &$message, $params) {
  switch ($key) {
    case 'cost_threshold_exceeded':
      $message['subject'] = t('Search API PostgreSQL: Cost threshold exceeded');
      $message['body'][] = t('The daily cost threshold of $@threshold has been exceeded.', [
        '@threshold' => $params['threshold'],
      ]);
      $message['body'][] = t('Current daily cost: $@cost', [
        '@cost' => $params['current_cost'],
      ]);
      $message['body'][] = t('Please review your AI usage and consider adjusting your configuration.');
      break;
      
    case 'error_threshold_exceeded':
      $message['subject'] = t('Search API PostgreSQL: Error threshold exceeded');
      $message['body'][] = t('The error threshold of @threshold errors has been exceeded.', [
        '@threshold' => $params['threshold'],
      ]);
      $message['body'][] = t('Current error count: @count', [
        '@count' => $params['error_count'],
      ]);
      $message['body'][] = t('Please check your configuration and system logs.');
      break;
  }
}

/**
 * Implements hook_cron_queue_info().
 *
 * Defines cron queues for the module.
 */
function search_api_postgresql_cron_queue_info() {
  $queues = [];
  
  $queues['search_api_postgresql_embedding'] = [
    'worker callback' => 'search_api_postgresql_process_embedding_queue_item',
    'time' => 60,
  ];
  
  return $queues;
}

/**
 * Queue worker callback for embedding generation.
 */
function search_api_postgresql_process_embedding_queue_item($data) {
  if (\Drupal::hasService('search_api_postgresql.embedding_queue_manager')) {
    $queue_manager = \Drupal::service('search_api_postgresql.embedding_queue_manager');
    if ($queue_manager) {
      return $queue_manager->processItem($data);
    }
  }
  
  throw new \Exception('Embedding queue manager service not available.');
}

/**
 * Implements hook_form_alter().
 *
 * Alters forms to add PostgreSQL-specific functionality.
 */
function search_api_postgresql_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Add PostgreSQL-specific help text to server forms
  if ($form_id === 'search_api_server_edit_form' || $form_id === 'search_api_server_add_form') {
    $server = $form_state->getFormObject()->getEntity();
    
    if ($server && $server->getBackend() && $server->getBackend()->getPluginId() === 'postgresql') {
      $form['backend_config']['#prefix'] = '<div class="messages messages--info">' .
        t('PostgreSQL backend provides advanced search capabilities including vector search and AI embeddings. Configure connection settings below.') .
        '</div>';
    }
  }
}